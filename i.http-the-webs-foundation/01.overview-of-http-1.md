# 1. HTTP 개관 \(1\)

### .1.1 HTTP: 인터넷의 멀티미디어 배달부

#### Q. HTTP는 무엇의 약자인가? 그 의미는 무엇인가?

HTTP는 하이퍼텍스트 전송 규약\(HyperText Transfer Protocol\)의 약자이다. 하이퍼텍스트\(hypertext\)란 참조\(하이퍼링크, hyperlink\)를 통해 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트를 말한다. \(위키백과\) http://www.google.com과 같이, 웹 페이지 주소의 시작 부분에 'http://'\(또는 'https://'\)를 명시함으로써 하이퍼텍스트 문서 교환을 http로 처리할 수 있다.

전통적인 텍스트는 한 텍스트를 읽기 위한 한 가지 선형적 순서가 전제되어 있다. 예를 들어 독자가 한 권의 책을 읽을 때 첫 페이지, 다음 페이지, ..., 마지막 페이지의 순서로 책을 읽을 것이라고 예상할 수 있다. 반면 하이퍼텍스트를 읽는 순서는 결정되어 있지 않은데, 노드\(node\)라고 불리는 페이지 단위 사이에 서로 다른 노드를 연결하는 링크\(link\)라는 연결점이 존재하기 때문이다.

HTTP는 클라이언트-서버 프로토콜이다. 사용자 에이전트\(예: 웹 브라우저\)는 하나의 개체\(예: HTML 문서\)에 대한 요청을 보낸다. 서버는 개 요청을 처리하고 응답\(response\)을 보내게 된다.

### 1.2 웹 클라이언트와 서버

### 1.3 리소스

#### Q. URL, URI, URN의 차이는 무엇인가?

* URI\(통합 자원 식별자, Uniform Resource Identifier\): 웹 서버 리소스 각각이 가지고 있는 이름이다. URI는 인터넷의 우편물 주소 같은 것으로, 리소스를 고유하게 식별하고 위치를 지정할 수 있다. URI의 두 가지 종류로 URL과 URN이 있다.
* URL\(통합 자원 지시자, Uniform Resource Locator\): 오늘날 대부분의 URI는 URL이다. 통상적인 관례에 따르면 URI와 URL을 같은 의미로 사용한다. URL은 특정 서버의 리소스에 대한 구체적인 위치를 서술한 것이다. 대부분의 URL은 세 부분으로 이루어진 표준 포맷을 따른다.
  * 스킴\(scheme\): 리소스에 접근하기 위해 사용되는 프로토콜. \(ex. http://\)
  * 서버의 인터넷 주소 \(ex.www.joes-hardware.com\)
  * 웹 서버의 리소스 \(ex. /specials/saw-blade.gif\)
* URN\(유니폼 리소스 이름, Uniform Resource Name\): 리소스의 위치에 영향 받지 않는 이름. \(ex. `urn:ietf:rfc:2141`\) 리소스의 위치가 바뀌거나, 리소스가 여러 군데 복사되거나, 여러 종류의 네트워크 접속 프로토콜로 리소스에 접근해도 같은 URN에 접근하면 같은 문서를 지칭한다. URN을 지원하는 인프라의 부재로, URN은 아직 실험적인 기능이고 널리 채택되지 못다. 

### 1.4 트랜잭션

### 1.5 메시지

#### Q. HTTP 메시지의 구조에 대해 자세히 서술하라.

ref: [https://developer.mozilla.org/ko/docs/Web/HTTP/Messages](https://developer.mozilla.org/ko/docs/Web/HTTP/Messages)

HTTP 메시지는 요청 메시지와 응답 메시지 두 종류가 있으며, 메시지는 시작줄, 헤더, 본문의 세 부분으로 나뉜다.

**\(1\) 시작줄**

요청이라면 무엇을 해야 하는지, 응답이라면 무슨 일이 일어났는지 나타낸다.

**요청 메시지**

ex. `GET /test/hi-there.txt HTTP/1.0`

* HTTP 메서드 \(GET, PUT, POST, ...\)
* 요청 타겟: URL, 쿼리, 옵션 포트, 서버 전체\(\*\) 등
* HTTP 버전: 응답 메시지에서 써야 할 HTTP 버전을 알려 준다.

**응답 메시지**

ex. `HTTP 1.0 200 OK`

* 프로토콜 버전 \(보통 HTTP/1.1\)
* 상태 코드: 요청의 성공 여부
* 상태 텍스트

**\(2\) 헤더**

헤더는 대소문자 구분 없는 문자열, 콜론\(:\), 값으로 이루어진다.

![](../.gitbook/assets/http_request_headers2.png)

**요청 메시지**

* Request 헤더: 요청의 내용을 구체화함 \(ex: Accept는 해당 형식으로 응답을 받고 싶다는 것이다.\)
* General 헤더: 메시지 전체에 적용되는 내용 \(ex: Via는 프록시를 경유해서 오면 생기는 헤더이다.\)
* Entity 헤더: 메시지 중 본문에만 적용되는 내용 \(ex. Content-type은 서버에게 어떤 종류의 리소스가 전송되는지를 명시한다.\)

![](../.gitbook/assets/http_response_headers2.png)

**응답 메시지**

* Response 헤더: 상태 줄에 미처 들어가지 못했던 서버에 대한 추가 정보 \(ex. Access-Control-Allow-Origin은 해당 응답이 주어진 origin으로부터의 요청을 허용함을 나타낸다.\)
* Entity 헤더: 메시지 중 본문에만 적용되는 내용 \(ex. Content-Encoding: 응답 개체가 압축된 인코딩 방법을 알려다.\)
* General 헤더: 메시지 전체에 적용되는 내용 \(ex. Connection: 전송이 완료된 후 네트워크 접속이 유지되는지를 뜻한다. keep-alive는 연결이 지속된다는 뜻이다.\)

**\(3\) 본문**

**요청 메시지**

리소스를 가져오는 요청은 보통 본문이 필요하지 않다. HTML 폼 데이를 포함하는 POST 요청과 같은 경우에는 본문이 포함된다.

* 단일 리소스 본문\(single resource bodies\): 헤더 두 개\(Content-Type와 Content-Length\)로 정의된 단일 파일로 구성된다.
* 다중-리소스 본문\(multiple resource bodies\): 주로 HTML 폼을 전송하는 데 사용되며, 본문이 여러 개의 파트로 나뉜다. 각 파트는 각기 다른 정보를 지닌다.

**응답 메시**

201\(created\), 204\(no content\)과 같은 상태 코드를 가진 응답에는 보통 본문이 없다.

* 길이를 알고 있는 파일의 단일 리소스 본문: 헤더 두개\(Content-Type와 Content-Length\)로 정의한다.
* 길이를 모르는 단일 리소스 본문: Transfer-Encoding가 chunked로 설정되어 있으며, 파일은 청크로 나뉘어 인코딩된다. \(cf. [https://b.pungjoo.com/entry/Transfer-Encoding-chunked-VS-Content-Length](https://b.pungjoo.com/entry/Transfer-Encoding-chunked-VS-Content-Length)\)
* 다중 리소스 본문: 상대적으로 보기 힘들다.

